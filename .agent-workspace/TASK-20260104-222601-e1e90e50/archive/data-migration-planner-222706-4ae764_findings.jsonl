{"timestamp": "2026-01-04T22:29:19.566412", "agent_id": "data-migration-planner-222706-4ae764", "finding_type": "insight", "severity": "high", "message": "Current state analysis: Only 5 recent tasks in SQLite (today's) vs 44 in GLOBAL_REGISTRY.json. Dashboard reads JSON directly causing stale counts. MCP partially uses SQLite via reconcile_task_workspace() but still writes to GLOBAL_REGISTRY.json", "data": {"tasks_in_json": 44, "tasks_in_sqlite": 5, "stale_active_agents": 102, "actual_active_agents": 0}}
{"timestamp": "2026-01-04T22:29:53.933662", "agent_id": "data-migration-planner-222706-4ae764", "finding_type": "recommendation", "severity": "critical", "message": "Data Migration Plan: 3-phase approach to migrate from JSON to SQLite as single source of truth", "data": {"phase_1_migration": {"name": "One-time Historical Data Migration", "description": "Migrate all 44 existing tasks from GLOBAL_REGISTRY.json to SQLite", "steps": ["1. Create migration script migrate_historical_tasks.py", "2. Iterate through all 44 tasks in GLOBAL_REGISTRY.json", "3. For each task, check if workspace exists in .agent-workspace/TASK-*", "4. If workspace exists: call reconcile_task_workspace() to sync AGENT_REGISTRY.json", "5. If no workspace: insert task metadata directly to SQLite with status=ARCHIVED", "6. Update task status lifecycle: INITIALIZED \u2192 ACTIVE (has agents) \u2192 COMPLETED/FAILED", "7. Run migration script once to populate state.sqlite3 with all historical data"], "risks": ["Some tasks may have incomplete data", "Need to handle malformed JSON entries", "Must preserve timestamps for historical accuracy"]}, "phase_2_api_updates": {"name": "Update Dashboard API to Read from SQLite", "description": "Modify dashboard/backend/api/routes/tasks.py to use SQLite instead of JSON", "changes": ["Replace _load_global_registries() with SQLite queries", "Use state_db.load_task_snapshot() for task details", "Implement proper task status transitions based on agent counts", "Add /api/tasks/{task_id}/reconcile endpoint for on-demand sync", "Update list_tasks() to query SQLite tasks table", "Fix active task counting logic using SQLite aggregates"], "benefits": ["Real-time accurate task/agent counts", "Faster queries via indexed SQLite vs JSON parsing", "Consistent state across all components"]}, "phase_3_deprecation": {"name": "Deprecate GLOBAL_REGISTRY.json Writes", "description": "Stop writing to GLOBAL_REGISTRY.json, keep as read-only backup", "steps": ["1. Remove all GLOBAL_REGISTRY.json write operations in real_mcp_server.py", "2. Keep GLOBAL_REGISTRY.json as historical backup (no writes)", "3. Update create_real_task to write directly to SQLite", "4. Update update_agent_progress to use state_db.record_progress() exclusively", "5. Add health_daemon.py periodic reconciliation for active tasks", "6. Implement SQLite \u2192 JSON export utility for disaster recovery"], "validation": ["Dashboard shows correct active counts", "Task status transitions work properly", "No more stale data accumulation"]}, "implementation_order": {"week_1": "Phase 1 - Migration script and historical data import", "week_2": "Phase 2 - Dashboard API updates", "week_3": "Phase 3 - Deprecate JSON writes and validation", "rollback_plan": "Keep GLOBAL_REGISTRY.json.backup, can revert API to read JSON if needed"}}}
{"timestamp": "2026-01-04T22:30:23.329880", "agent_id": "data-migration-planner-222706-4ae764", "finding_type": "solution", "severity": "high", "message": "Migration Script Implementation Details - migrate_historical_tasks.py", "data": {"script_structure": {"location": "orchestrator/migrate_historical_tasks.py", "purpose": "One-time migration of all historical tasks from JSON to SQLite", "execution": "python orchestrator/migrate_historical_tasks.py --dry-run (test) then without flag (execute)"}, "key_functions": {"migrate_all_tasks": "Main entry point - reads GLOBAL_REGISTRY.json and migrates each task", "migrate_single_task": "Handles one task: check workspace, call reconcile or insert metadata", "compute_task_status": "Determines proper status based on agent states (INITIALIZED/ACTIVE/COMPLETED/FAILED)", "backup_existing_data": "Creates timestamped backups of both JSON and SQLite before migration", "verify_migration": "Post-migration validation comparing counts and data integrity"}, "error_handling": {"missing_workspace": "Tasks without workspace folders get status=ARCHIVED", "malformed_json": "Log error, skip task, continue with rest", "sqlite_conflicts": "Use ON CONFLICT DO UPDATE to handle existing entries", "partial_failure": "Transaction per task, log failures, generate report"}, "data_mapping": {"task_status_logic": "INITIALIZED (no agents) -> ACTIVE (agents running) -> COMPLETED (all done) -> FAILED (errors)", "agent_normalization": "Use state_db.normalize_agent_status() for consistent statuses", "timestamp_preservation": "Keep original created_at/updated_at from JSON", "phase_reconstruction": "If phases missing, create single DEFAULT phase"}, "validation_steps": ["1. Count tasks: JSON vs SQLite should match", "2. Check agent counts per task", "3. Verify status transitions are logical", "4. Ensure no data loss (diff JSON vs SQLite exports)", "5. Test dashboard displays correctly"], "rollback_capability": {"backup_files": "GLOBAL_REGISTRY.json.migrate_backup, state.sqlite3.migrate_backup", "restore_command": "python orchestrator/migrate_historical_tasks.py --rollback", "safe_mode": "Keep JSON read-only for 30 days before deletion"}}}
{"timestamp": "2026-01-04T22:30:47.438463", "agent_id": "data-migration-planner-222706-4ae764", "finding_type": "solution", "severity": "high", "message": "Dashboard API Changes Required - SQLite Integration", "data": {"file": "dashboard/backend/api/routes/tasks.py", "changes_required": {"imports": ["Add: from orchestrator import state_db", "Add: import sqlite3"], "list_tasks_endpoint": {"current": "Reads from GLOBAL_REGISTRY.json via _load_global_registries()", "new": "Query SQLite: SELECT * FROM tasks LEFT JOIN agent counts", "implementation": ["db_path = state_db.get_state_db_path(WORKSPACE_BASE)", "conn = sqlite3.connect(db_path)", "Query tasks with aggregated agent counts", "Return TaskSummary objects from SQLite data"], "benefits": "Real-time accurate counts, no JSON parsing overhead"}, "get_task_detail_endpoint": {"current": "Reads AGENT_REGISTRY.json from workspace", "new": "Use state_db.load_task_snapshot(task_id)", "implementation": ["Call state_db.reconcile_task_workspace(workspace) first", "Then state_db.load_task_snapshot() for full details", "Transform to TaskDetail model"], "benefits": "Consistent with MCP server, includes phase data"}, "new_endpoints": {"/tasks/{task_id}/reconcile": "Force reconcile workspace to SQLite", "/tasks/stats": "Global statistics from SQLite aggregates", "/tasks/active": "Real-time active tasks with proper filtering"}, "active_count_fix": {"problem": "Currently counts any task with active_agents > 0 (stale)", "solution": "Query SQLite: SELECT COUNT(*) FROM agents WHERE status IN ('running','working','blocked')", "expected_result": "Dashboard shows 0 active when no agents running"}}, "testing_plan": ["1. Run migration script first", "2. Update API endpoints one by one", "3. Test dashboard displays correct counts", "4. Verify task details load properly", "5. Check performance improvement"], "backward_compatibility": {"keep_json_fallback": "If SQLite empty, fall back to JSON temporarily", "gradual_rollout": "Feature flag to switch between JSON/SQLite", "monitoring": "Log response times and error rates"}}}
