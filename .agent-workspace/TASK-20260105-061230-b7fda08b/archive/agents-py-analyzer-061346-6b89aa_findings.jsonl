{"timestamp": "2026-01-05T06:14:44.013138", "agent_id": "agents-py-analyzer-061346-6b89aa", "finding_type": "insight", "severity": "medium", "message": "Complete analysis of agents.py JSON registry reads - found 6 occurrences", "data": {"file": "dashboard/backend/api/routes/agents.py", "total_reads": 6, "reads": [{"line": 136, "function": "_resolve_tracked_file", "code": "registry = read_registry_with_lock(str(registry_path)) or {}", "purpose": "Reading AGENT_REGISTRY.json to get tracked file paths for a specific agent", "data_accessed": "agents list with tracked_files for each agent", "state_db_replacement": "get_agent_by_id(task_id, agent_id) to get agent's tracked_files directly"}, {"line": 230, "function": "list_agents (GET /{task_id})", "code": "registry_data = read_registry_with_lock(str(registry_path))", "purpose": "Reading AGENT_REGISTRY.json to list all agents for a task", "data_accessed": "Full agents array with all agent details", "state_db_replacement": "get_agents_by_task(task_id) to fetch all agents from SQLite"}, {"line": 270, "function": "get_agent (GET /{task_id}/{agent_id})", "code": "registry_data = read_registry_with_lock(str(registry_path))", "purpose": "Reading AGENT_REGISTRY.json to find a specific agent by ID", "data_accessed": "Full agents array, then filtering for specific agent_id", "state_db_replacement": "get_agent_by_id(task_id, agent_id) to fetch agent directly from SQLite"}, {"line": 24, "function": "read_registry_with_lock (fallback implementation)", "code": "with open(path, 'r') as f: return json.load(f)", "purpose": "Fallback implementation when orchestrator imports fail", "data_accessed": "Any registry file (AGENT_REGISTRY.json or GLOBAL_REGISTRY.json)", "state_db_replacement": "Not needed - should import state_db functions instead"}, {"line": 105, "function": "_read_last_progress", "code": "return json.loads(line)", "purpose": "Reading progress JSONL file (not registry)", "data_accessed": "Progress updates from {agent_id}_progress.jsonl", "state_db_replacement": "Not a registry read - this is JSONL progress data, keep as-is"}, {"line": 368, "function": "get_agent_findings", "code": "data = json.loads(line)", "purpose": "Reading findings JSONL file (not registry)", "data_accessed": "Findings from {agent_id}_findings.jsonl", "state_db_replacement": "Not a registry read - this is JSONL findings data, keep as-is"}], "summary": "3 critical registry reads need migration to state_db (lines 136, 230, 270). The other JSON operations are for JSONL files (progress/findings) which don't need migration.", "migration_priority": [{"endpoint": "GET /{task_id}", "line": 230, "impact": "High - Most frequently called endpoint", "replacement": "state_db.get_agents_by_task(task_id)"}, {"endpoint": "GET /{task_id}/{agent_id}", "line": 270, "impact": "High - Core agent detail endpoint", "replacement": "state_db.get_agent_by_id(task_id, agent_id)"}, {"function": "_resolve_tracked_file", "line": 136, "impact": "Medium - Helper function used by progress/findings/logs endpoints", "replacement": "state_db.get_agent_by_id(task_id, agent_id) then access tracked_files"}]}}
{"timestamp": "2026-01-05T06:15:10.552806", "agent_id": "agents-py-analyzer-061346-6b89aa", "finding_type": "recommendation", "severity": "high", "message": "Migration strategy for agents.py to use state_db", "data": {"migration_steps": [{"step": 1, "action": "Add state_db imports", "code": "from orchestrator.state_db import get_agents_by_task, get_agent_by_id, ensure_db", "location": "Top of agents.py after other orchestrator imports"}, {"step": 2, "action": "Replace list_agents registry read", "current_line": 230, "current_code": "registry_data = read_registry_with_lock(str(registry_path))\nagents = registry_data.get('agents', [])", "new_code": "agents_data = get_agents_by_task(task_id)\nagents = agents_data or []", "notes": "Direct SQLite query, no file I/O"}, {"step": 3, "action": "Replace get_agent registry read", "current_line": 270, "current_code": "registry_data = read_registry_with_lock(str(registry_path))\nfor agent in registry_data.get('agents', []):\n    if agent['id'] == agent_id:", "new_code": "agent = get_agent_by_id(task_id, agent_id)\nif agent:", "notes": "Direct lookup by ID, much more efficient"}, {"step": 4, "action": "Update _resolve_tracked_file", "current_line": 136, "current_code": "registry = read_registry_with_lock(str(registry_path)) or {}\nfor agent in registry.get('agents', []):", "new_code": "agent = get_agent_by_id(task_id, agent_id)\nif agent and agent.get('tracked_files'):", "notes": "Use state_db for agent lookup, still use tracked_files field"}], "benefits": ["Eliminate file I/O bottleneck from JSON reads", "Direct SQLite queries are much faster", "No more file locking issues", "Better concurrency support", "Atomic operations without race conditions"], "keep_unchanged": ["Progress JSONL reads (lines 105, 312)", "Findings JSONL reads (lines 368, 363)", "Log JSONL reads (lines 432, 584)", "These are event streams, not registry data"], "testing_approach": ["Ensure state_db is initialized on API startup", "Test all endpoints still return same data structure", "Verify performance improvement with load testing", "Check that archived agents still appear correctly"], "fallback_note": "Keep read_registry_with_lock import available as fallback for tasks that haven't been migrated to SQLite yet"}}
